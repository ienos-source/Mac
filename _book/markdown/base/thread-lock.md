# 线程锁

##### @synchronized
一般在创建单例对象时使用
##### atomic
修饰属性的关键字
##### OSSpinLock
自旋锁，循环等待询问，不释放当前资源；主要用于轻量级数据访问，简单的 int +1/-1 操作
##### NSLock
不可以嵌套 lock/unlock
##### NSRecursizeLock
递归锁，解决 NSLock 不可嵌套问题
##### dispatch_semaphore_t
信号量
```Objective-C
/// 保存 value = 1
dispatch_semaphore_create(1);
/// value --; 当 value < 0，阻塞 Thread
dispathc_semaphore_wait()
/// value ++；当 value >= 0，唤醒 Thread
dispatch_semaphore_singal()
```

### 线程锁的分类

##### 自旋锁

线程会反复检查变量是否可用，由于线程在这个过程中一直保持执行，所以是一种忙等待。一旦获取自旋锁，线程就会一直保持该锁，直到显式释放自旋锁。自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。对于 iOS 属性的修饰词 atomic，自带一把自旋锁

- OSSpinLock
- atomic

##### 互斥锁

互斥锁是一种用于多线程中，防止两条线程同时对同一个资源（例如全局变量）进行读写的机制，该目的是通过将代码切成一个个临界区而达成

- @synchronized
- NSLock
- pthread_mutex

##### 条件锁

条件变量，当进程的某些资源要求不满足时就进入休眠，即锁住了，当资源被分配到了，条件锁打开了，进程继续运行

- NSCondition
- NSConditionLock

##### 递归锁

递归就是同一个线程可以加锁 N 次而不会引发死锁。递归锁是特殊的互斥锁，即是带有递归性质的互斥锁

- pthread_mutex(recursive)
- NSRecursiveLock

##### 信号量

是一种更高级的同步机制，互斥锁可以说是 semaphore 在仅取值 0/1 的特例，信号量可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥

- dispatch_semaphore

##### 读写锁

读写锁是一种特殊的自旋锁。将共享资源的访问分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作。这种锁相对于自旋锁而言，能提高并发性

- 一个读写锁同时只能有一个写者或者多个读者，但不能既有读者又有写者，在读写锁保持期间也是抢占失效的

- 如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，知道没有任何写者或者读者。如果读写锁没有写者，那么读者可以立刻获得读写锁。

### 原子性

保证"检查-占锁"
