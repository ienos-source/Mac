{"./":{"url":"./","title":"Introduction","keywords":"","body":"Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:11:59 "},"markdown/base/runtime.html":{"url":"markdown/base/runtime.html","title":"Runtime","keywords":"","body":"Runtime |- 数据结构 |- 类对象与元类对象 |- 消息传递 |- 方法缓存 |- 消息转发 |- [Method-Swizzling](markdown/base/method-swizling.md) |- 动态添加方法 |- 动态方法解析 数据结构 objc_object { isa { isa raw isa nonpointer_isa 共用体，利用位域存储信息 { nonpointer // 是否开启指针优化 has_assoc // 是否有关联对象 has_cxx_dtor // 是否有析构函数 shiftcls // 存储类指针的值 magic // 判断当前对象是对象还是未被初始化的空间 weakly_reference // 是否有被弱引用 deallocating // 是否正在释放 has_sidetable_rc // 是否使用 SideTable 进行引用计数 extra_rc // 表示该对象的引用计数值 } } } alloc & init & new { alloc _objc_rootAlloc callAlloc { objc_msgSend }, { _objc_rootAllocWithZone _class_createInstanceFromZone { /// 计算出需要的内存空间 /// 向系统申请开启内存，返回地址指针 /// 关联到相应的类 } } } init 直接返回 self new 相当于 alloc + init ` objc_object id -> objc_object { isa_t // 共用体 关于 isa 操作相关 弱引用相关 关联对象相关 内存管理相关 } objc_class Class -> objc_class: objc_object { Class superClass cache_t cache class_data_bits_t bits { class_rw_t { // 可读可写 class_ro_t, { // 只读 name, ivars, properties, // 一维数组 protocols, // 一维数组 methodList [ { // method_t SEL name const char* types IMP imp } ] // 一维数组 } protocols, // list_array_tt 二维数组 properties, // list_array_tt 二维数组 methods // list_array_tt 二维数组 {{method_t}} } } } isa 指针 指针型 isa、非指针型 isa 共用体 isa_t cache_t cache_t { _buckets [ bucket_t { key(SEL) : IMP }, bucket_t { }, ... ] _mask // 掩码 _flags _occupied // 已缓存的方法数 } { 实例方法缓存在类上面，类方法缓存在元类上面 利用 SEL 和 mask 掩码计算索引下标 运用可增量扩展的哈希表结构，提前扩容防止溢出，如果缓存容量超过原来的 3/4，进行内容扩容 开放寻址法解决哈希冲突，从发生冲突的单元起，尝试选择另外单元，直到找出空的单元为止 { cache 中使用线性探查法, 即 index ++，寻找下一个 再散列 平方探测法？ } } 介绍 Runtime 的内存模型 isa、对象、类、metaclass、结构体的存储信息等等 对象和类都是 objc_object 结构体，都有 isa 指针 实例 --isa--> Class Class --isa--> MetaClass 元类的 isa 指针指向 NSObject 元类，NSObject 元类的 isa 指针指向自己 NSObject 元类的 superClass 指针指向 NSObject 类，也就是说当 对象的 isa 指针指向类，类保存着实例对象的属性列表、方法列表、成员列表等相关信息 类的 isa 指针指向元类，元类保存着类对象的方法列表及其他相关信息 相关信息包括成员列表 objc_ivar_list、方法列表 objc_method_list、协议列表 objc_protocol_list 消息查找过程 编译后的代码最终都会转成 objc_msgSend(id, SEL, ...)方法进行调用，runtime 通过这个 id 对象的 isa 指针找到这个对象的类对象，从类对象中的 cache 中查找是否存在 SEL 对应的 IMP，若不存在，则在类对象中查找方法列表，找到对应的方法实现，如果没有找到则顺次查找 superClass 的方法列表，直到 superClass = nil class -> isa 指针找到元类对象，在元类对象中查找方法列表，找到对应的方法实现，如果没有找到则顺次查找 superClass 的方法列表，当找到 Root Class 元类时，Root Meta Class 的 superClass 为 Root Class，Root Class 的 superClass = nil 消息传递 void objc_msgSend(id self, SEL op, ...) [super class] objc_msgSendSuper(struct objc_super *super, SEL op, ...) /// 编译器关键字 struct objc_super { __unsafe_unretained id receiver; // self } [self class] objc_msgSend super 是编译器的指示符，不是指针，只是一个标识符，代表调用父类的方法，调用者还是自己本身 superClass 获取该类的父类方法 例如 Person 继承 NSObject @interface Person: NSObject @end 在 Person 中调用实现下面几个方法 /// Person [self class] /// NSObject [self superClass] /// Person [super class] /// NSObject [super superClass] /// NSObject [[super class] superclass] { 缓存是否命中 invoke 当前类方法列表是否命中 逐类父类方法列表是否命中 } 消息转发 { // 参数为 Selector，判断是否处理 Selector 方法，类方法，这里可以动态添加方法实现 - (BOOL)resolveInstanceMothod:(SEL) { // 动态添加方法实现 class_addMethod(self, @selector(test), testImp, \"v@:\") } // 转发目标 - (id)forwardingTargetForSelector:(SEL) // 返回方法签名 [NSMethodSignature - (NSMethodSignature)methodSignatureForSelector:(SEL) signatureWithObjCType:\"v@:\"] // 判断是否能处理该方法 - forwardInvocation: - 消息无法处理 } 缓存查找 给定值是 SEL，目标值是对应 bucket_t 中的 IMP cache_key_t -> f(key) -> bucket_t f(key) = key & mask 当前类中查找 对于已排序好的列表，采用二分查找算法查找方法对应执行函数 对于没有排序的列表，采用一般遍历查找方法对应执行函数 父类逐级查找 开始 -> curClass = curClass -> superclass -> curClass == nil -> 结束 curClass != nil -> 缓存是否命中 -> 方法列表是否命中 -> curClass -> superclass 为什么要设计 metaclass metaclass 是元类，存储类的方法，目的是将它与实例方法及构建信息区分开 动态添加方法 performSelector: 在运行时使用，配合 respondsToSelector: 判断该对象是否响应该方法，该方法可以指定线程，但是使用时要确保 RunLoop 是否是开启状态，原理是添加一个 Timer，在 RunLoop 中执行 其他: 利用 performSelector 防止多次点击的应用 cancelPreviousPerformRequestsWithTarget: performSelector:afterDelay:0.2s 相对于 NSMethodSignature 和 NSInvocation，performSelector 只能传递一个参数 { NSMethodSignature alloc]initWithSelector]; NSInvocation alloc]initWithMethodSignature]; { target selector setArgument:atIndex invoke getReturnValue } } 动态方法解析 @dynamic 动态运行时语言将函数决议推迟到运行时 编译时语言在编译期间进行函数决议 load 当类被加载的时候，被调用，且只调用一次；调用的方法并不是采用 runtime 的 objc_msgSend 方法调用，而是采用函数地址直接调用多个类的 load 调用顺序。load 调用顺序是依赖于 Complile Sources 的文件顺序决定的。父类方法优先于子类方法，Category 优先于本类的 load 方法，所有 load 方法都会被调用 调用判断规则如下: 如果当前类没有父类，则调用该类的 load 方法。如果当前类还有父类，则从该类的父类开始调用，直到当前类，然后开始下一个文件 Complile Sources 文件判断 initalize 当类或子类第一次收到消息时被调用，即静态方法或实例方法第一次被调用，也就是这个类第一次被用到的时候，只调用一次。调用方式是通过 runtime 的 objc_msgSend 的方式调用的，此时所有的类已经装载完毕。子类和父类同时实现 initialize，category 会覆盖本类的方法，只调用 category 的，在类或其子类的第一个方法被调用前调用，由于是系统调用，不再需要调用 [super initalize] 父类的 initalize 方法会比子类先进行 当子类未实现 initalize 方法时，会调用父类 initalize 方法，子类实现 initalize 方法时，会覆盖父类的 initalize 当有多个 Category 都实现了 initalize 方法，会覆盖类中的方法，只执行一个（会执行 Complile Sources 列表中最后一个 Category 的 initalize） class_copyIvarList & class_copyPropertyList class_copyIvarList 获取的是成员变量列表，@interface {} 中声明的变量 class_copyPropertyList 获取的是属性列表，@property 声明的变量 # 编译后的类不能新增实例变量，动态添加的类可以新增实例变量 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 17:17:47 "},"markdown/base/runloop.html":{"url":"markdown/base/runloop.html","title":"RunLoop","keywords":"","body":"RunLoop 线程只能执行一次任务，执行完任务只有便退出，RunLoop 是通过内部维护的事件循环来对事件/消息进行管理的一个对象 优点 程序能够一直运行并且接受用户的输入 调用解耦，主调方产生很多事件，不用等到被调用方处理完事件之后，才执行其他操作 没有消息需要处理时，休眠以避免资源占用 用户态 -> 内核态 有消息处理时，立刻被唤醒 内核态 -> 用户态 每个 RunLoop 都包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer；RunLoop 只能在一种 Mode 下面执行，当需要切换 Mode 的时候，就必须退出当前 RunLoop，重新进入 RunLoop。Source/Timer/Observer 被统称为 Item，一个 Item 可以被同时加入多个 Mode，如果一个 Mode 中一个 Item 都没有，则 RunLoop 会直接退出，不进入循环 { CFRunLoop { pthread // RunLoop 和 线程一一对应，其关系保存在一个全局的字典中 currentMode // CFRunLoopMode modes // NSMutableSet commonModes // NSMutableSet commonModeItems // Observer / Timer / Source } Mode CFRunLoopMode { name // NSDefaultRunLoopMode source0 // 需要手动唤醒线程 source1 // 具备唤醒线程的能力 observers timers } CFRunLoopCommonModes { - commonMode 不是实际存在的一种 Mode - 是同步 Source/Timer/Observer 到多个 Mode 中的一种技术方案 } Source { Source0 Source1 Timer Source } Timer CFRunLoopTimer { 基于事件的定时器 一个 Timer 如何添加到多个 Mode } Observer CFRunLoopObserver { 观测时间点 kCFRunLoopEntry kCFRunLoopBeforeTimers kCFRunLoopBeforeSources kCFRunLoopBeforeWaiting // 即将切换到内核态 kCFRunLoopAfterWaiting // 切换到用户态之后 kCFRunLoopExit } 接收消息 处理消息 等待不等于死循环 } NSRunLoop 是 CFRunLoop 的封装，面向对象的 API Timer / PerformSelector RunLoop 的执行过程 1. 即将进入 RunLoop 2. 将要处理 Timer/Source0 事件 3. 处理 Source0 事件 4. 如果有 Source1 要处理，跳转 [8] 5. 线程将要休眠 6. 休眠等待唤醒 (Source1, Timer 事件，外部手部唤醒) 7. 线程刚被唤醒 8. 处理唤醒时收到的消息，跳转 [2] 9. 即将退出 RunLoop 常见问题 滑动 TableView 的时候我们定时器还会生效吗 kCFRunLoopDefaultMode --Mode 发生转换--> UITrackingRunLoopMode 利用 CommonMode 标记，然后将 Timer 添加到多个 Mode 中 RunLoop 和 PerformSelector 当调用 NSObject 的 performSelector:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中，所以如果当前线程没有 RunLoop，则这个方法会失效，如果有 RunLoop 也需要 run 起来 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效 RunLoop 和 多线程 线程是和 RunLoop 一一对应的 自己默认创建的线程默认是没有 RunLoop 的 主线程中的 MainRunLoop 默认是创建并且运行激活的 RunLoop 的销毁是发生在线程结束时 一个线程里面是可以开启多个 RunLoop，只能嵌套在大 RunLoop 中 怎样实现一个常驻线程 为当前线程开启一个 RunLoop（currentRunLoop 懒加载） 向该 RunLoop 中添加一个 Port/Source 等维持 RunLoop 的事件循环 启动 RunLoop while(runAlways) { @autoreleasepool { CFRunLoopRunInMode(until: future) } } Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/base/KVC.html":{"url":"markdown/base/KVC.html","title":"KVC","keywords":"","body":"KVC Key-Value Coding Programm1ing Guide: About Key-Value Coding 本质 通过字符串获取对象属性 对象 NSObject 应用 自定义 Model 打印 |- Key-Value (NSKeyValueCoding) |- 路由，多层结构 |- Key |- setValue:forKey |- 通过相关名字调用 setter 方法 |- 是否允许访问成员变量 |- accessInstanceVariableDirectly |- Undenfined |- 映射处理 |- valueForKey |- 通过相关名字调用相关 getter 方法 |- 集合类型判断 |- accessInstanceVariableDirectly |- 通过相关名字获取实例变量 |- Value |- 数据类型 |- 对象类型 |- 基本数据类型 |- NSValue |- struct |- NSNumber |- int / float / char |- 数据结构 |- item |- collection |- operators Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/base/KVO.html":{"url":"markdown/base/KVO.html","title":"KVO","keywords":"","body":"KVO 如何自己动手实现 KVO Introduction to Key-Value Observing Programming Guide 本质 基于 KVC 的键值观察者模式 思想 观察者模式 原理 当一个对象添加了 KVO 监听，iOS 系统会通过 Runtime 动态创建一个子类，并让这个对象的 isa 指向这个新创建的子类。子类拥有自己的 setter 方法实现，setter 方法内部会调用 willChangeValueForKey 方法，原来的 setter 方法、didChangeValueForKey 方法，在 didChangeValueForKey 方法内部优惠调用 observeValueForKeyPath 监听方法。所以本质上，调用 willChangeValueForKey 和 didChangeValueForKey 就可以出发 KVO。直接修改成员变量不会触发 KVO 过程 isa 指针重定向，Class，NSKVONotifying_Class(Class 子类)，_isKVO，dealloc，setPropertyName: 关联 observers -> observeInfo -> key / value NSKeyValueWillChange / NSKeyValueDidChange observeValueForKeyPath removeObserver:forKeyPath isa 复原 IIDB watch var 缺点 如果移除未添加的 KeyPath 导致崩溃，需要在 dealloc 中移除所有 KeyPath，只能在 observeValueForKeyPath 如何手动关闭 KVO \b重写被观察对象的 automaticallyNotifiesObservesForKey 方法，返回 NO 重写 automaticallyNotifiesObservesForKey，返回 NO 注意，关闭 KVO 后，需要手动在赋值前后添加 willChangeValueForKey 和 didChangeValueForKey，才可以收到观察通知 哪些情况下使用 KVO 会崩溃，怎么防护崩溃 removeObserver 一个未注册的 keyPath，导致错误 Cannot remove an observe A for the key path \"str\"，because it is not registered as an observer。解决方法: 根据实际情况，增加一个添加 keyPath 的标记，在 dealloc 中根据这个标记，删除观察者 添加的观察者已经销毁，但是未被移除这个观察者，当下次这个观察者的 keyPath 发生变化时，KVO 中的观察者的引用变成了野指针，导致 crash。解决方法: 在观察者即将销毁的时候，先移除这个观察者。也可以将观察者 observer 委托给另外一个类去完成，这个类弱引用被观察者，当这个类摧毁的时候，移除观察者对象 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/base/block.html":{"url":"markdown/base/block.html","title":"Block","keywords":"","body":"Block Block-ABI-Apple 本质 携带上下文的对象 结构 { isa, FuncPtr, flags, reserved, desc { block_size, reserved, copy & dispose(id 类型) { 栈 -> 堆 堆 引用计数 + 1 全局不处理 } } } 形式 有参有返 有参无返 无参无返 无参有返 分类 栈：编译时 堆：栈 copy 变成 堆 全局：没有捕获变量、编译时 __block 作用 将非对象类型包裹成对象类型 对象分类 对象类型和常见数据类型 结构 isa、__forwarding、flags __forwarding 保证当对象在堆上，确保值的更新及获取是以堆上的为准 修饰词 copy: 防止在栈区中随作用域的结束而丢失数据 strong: retain 实现依旧是 copy 对象捕获 __block 修饰 { 常见数据类型 对象类型 { 分类 { id block } 新增方法 { copy & dispose { 场景 { __weak __block block __weak __block id __block id __block block } 不处理 } } } 结构 { isa flags { 引用计数 是否有 copy & dispose 内存管理模式 (strong/weak/GC) 堆 / 栈 } reserved size __forwarding { 栈 -> 堆 堆 -> self } } } 根据变量分类 全局变量: 直接取值不捕获 静态全局变量: 直接取值不捕获 局部变量: 对象指针拷贝，常见数据类型值拷贝 静态局部变量: 指针捕获 静态与非静态区别: 是否只作用于该源文件 循环引用 原因: A 持有 B，B 持有 A，引用计数始终大于 0，无法释放 解决方法: 中介者模式 + 弱指针，A 持有 B，B 持有指向 A 的弱指针 weak + strong: 防止 block 已经在执行过程中， weak 指向的对象提前释放 为什么用 weak 而不用 unretained？虽然均不进行强引用，但当对象释放时，指针仍指向原先的地址 MRC / ARC ARC 调用 copy 时机 block 作为返回值 将 block 赋值给 __strong 指针 block 作为 usingBlock 方法参数 block 作为 GCD 方法参数 MRC 源码 libclosure 应用场景 反向传值 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/base/memory.html":{"url":"markdown/base/memory.html","title":"内存管理","keywords":"","body":"内存管理篇 |- 内存布局 |- 内存管理方案 |- 数据结构 |- ARC & MRC |- 引用计数 |- 弱引用 |- 自动释放池 |- 循环引用 什么是野指针 指的是指针指向已经被释放了的内存地址 一般情况下会使用 Zombie Object 进行调试，hook 到 object_dispose(id objc) 函数中，在 free 前调用 object_setClass(self, zombieClass)，修改对象的 isa 指针，指向一个名为 __NSZombie + 类名 的结构体。当该对象再次收到 objc_msgSend，调用 abort() 崩溃并打印出调用的方法 Objective-C 主要有三种方式 ARC(自动内存计数)、手动内存计数、内存池 内存管理的几条原则 autorelease 数据持久化 内存分区 为了让内存最大程度被利用、堆和栈分别一个从高位到地位，一个从低位到高位开始分配，直至最后内存发生溢出 栈是从高到低的一块连续内存空间，先进后出 堆是从低到高且不连续的内存空间，会存在内存碎片，链表结构 内核区 高 0xc0000000 栈 Stack 🔽 堆 Heap 🔼 程序 未初始化数据 .bss 未初始化的全局变量 已初始化数据 .data 已初始化的全局变量 代码段 .text 低 0x08048000 程序代码 保留 堆 栈: 自动变量 静态区（全局区） 常量区 代码区 内存管理方案 - TaggedPoint 小对象 NSNumber - nonpointer_isa 64bit，内存管理的数据内容 { indexed // 是否为 nonpointer_isa has_assoc // 关联对象 has_cxx_dtor // shiftcls // 指针地址 magic // weakly_reference // 弱引用 deallocating // has_sidetable_rc // 是否用 SideTable extra_rc // 额外引用计数 } - 散列表 引用计数表，弱引用计数表 { SideTables() 哈希表 [ 64 个 SideTable（非嵌入式） ] SideTable { spinlock_t // 自旋锁 RefcountMap // 引用计数表 weak_table_t // 弱引用表 } /// 为什么不是一个 SideTable，考虑到多线程访问需要加锁处理，如果所有对象都操作同一张表会存在效率问题 /// 分离锁 当一个资源可以分成很多部分的时候，如果对每个部分使用不同的锁，那么资源的争用就大大降低 /// 如何实现快速分流 SideTables 本质是一张 Hash 表，如何快速定位某个对象的引用计数在哪个 SideTable ptr % array.count } 自旋锁 spinlock_t 是一种\"忙等\"的锁。对这个线程进行阻塞休眠，适用于轻量访问（适用 SideTable，只需要引用计数 +1/-1） 引用计数表 RefcountMap ptr -- DisguisedPtr(objc_object) --> size_t { // 数据结构 size_t weakly_reference deallocating RC } 弱引用表 weak_table_t weak_table_t hash 函数后得到 weak_entry_t { weak_entry_t 是 weakPtr 数组 } 自动释放池 AutoreleasePool MRC 手动引用计数 alloc、retain、release、retainCount、autorelease、dealloc ARC 自动引用计数 ARC 是 LLVM 和 Runtime 协作的结果 ARC 中禁止手动调用 retain/release/reatinCount/dealloc ARC 中新增 weak、strong 属性关键字 引用计数管理 实现原理分析 - alloc: 经过一系列调用，最终调用了 C 函数 calloc，此时并没有设置引用计数为 1 - retain: // 经过两次哈希查找 SideTable& table = SideTables()[this]; // size_t 无符号 long 型 size_t& refcntStorage = table.refcnts[this]; refcntStorage += SIDE_TABLE_RC_ONE; - release SideTable& table = SideTables()[this]; RefcountMap::iterator it = table.refcnts.find(this); it->second -= SIDE_TABLE_RC_ONE; - retainCount SideTable& table = = SideTables()[this]; size_t refcnt_result = 1; RefcountMap::iterator it = table.refcnts.find(this); refcnt_result += it->second >> SIDE_TABLE_RC_ONE; - dealloc _objc_rootAlloc() -> rootDealloc { 是否可以直接释放，如果是调用 C 函数 free - nonpointer_isa - weakly_reference - has_assoc // 是否有关联对象 - has_cxx_dtor // 是否有 C++ 关联对象 - has_sidetable_rc // 引用计数表是否通过 SideTable 控制 否则需要调用 object_dispose { objc_destructInstance() { 当前对象是否有 C++ 相关内容, object_cxxDestruct() 当前对象是否有关联对象, _object_remove_assocations() clearDeallocating { sidetable_clearDeallocating() weak_clear_no_lock // 将指向该对象的弱引用指针置 nil table.refcnts.erase() // 从引用计数表中擦除该对象的引用计数 } } C 函数 free } } 修饰词 atomic weak strong copy 循环引用 block delegate timer WKWebView delegate Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/base/weak.html":{"url":"markdown/base/weak.html","title":"weak","keywords":"","body":"Weak Weak 修饰的释放自动被置为 nil 的实现原理 // 编译前 id __weak obj1 = obj; // 编译后 id obj1; objc_initWeak(&obj1, obj); objc_initWeak() storeWeak() weak_register_no_lock() { weak_table_t { // 存储方式分为两个部分: inline_referrers 定长数组、 referrers 动态数组、索引为 referrer 的散列值，当 referrer 的个数不超过 WEAK_INLINE_COUNT 4 时，使用 inline_referrers，否则使用 referrers weak_entry_t [ index = hash_ptr(referent) ] } } Runtime 维护着一个 Weak 表，用于存储指向某个对象的所有 Weak 指针 Weak 表是 Hash 表，Key 是所指对象的地址，Value 是 Weak 指针地址的数组 在对象被回收的时候，经过层层调用，最终会触发下面的方法将所有 Weak 指针的设置为 nil。runtime 源码，objc-weak.m 的 arr_clear_deallocating 函数 Weak 指针的使用涉及到 Hash 表的增删改查，有一定的性能开销 置 nil 过程 dealloc weak_clear_no_lock Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/base/autorelease.html":{"url":"markdown/base/autorelease.html","title":"autorelease","keywords":"","body":"Autorelease Apple-Autorelease 结构 是以栈为节点，通过双向链表的形式组合而成，是和线程一一对应的 { id *next; AutoreleasePool* const parent; AutoreleasePool* child; pthread_t const thread; } 每个 AutoreleasePoolPage 中包含一个栈，从高地址向低地址开始对每个对象进行入栈操作 每次进行 AutoreleasePoolPage::push 就是在栈中 push 一个哨兵对象，这个哨兵对象的值为 nil，next 指针指向下一个对象 AutoreleasePoolPage::pop 就是将，距离哨兵对象位置（也就是上次 push 的节点）的所有对象依次发送 release 消息，并回退 next 指针 - (void)viewDidLoad { [super viewDidLoad]; /// array 什么时候释放， /// 当每次 runLoop 将要结束的时候调用 AutoreleasePoolPage::pop() /// for alloc 图片数组等内存消耗较大的场景手动插入 autoreleasePool NSMutableArray *array = [NSMutableArray array]; } AutoreleasePool 的实现原理是怎样的 编译器会将 @autoreleasepool{} 改写为: void *ctx = objc_autoreleasePoolPush(); { // code } objc_autoreleasePoolPop(ctx); void* objc_autoreleasePoolPush(void) { void* AutoreleasePoolPage::push(void) } void objc_autoreleasePoolPop(void *ctx) { // 一次 pop 实际上相当于一次批量的 pop 操作，针对的对象是所有 {} 中的对象进行 release 操作 AutoreleasePoolPage::pop(void* ctxt) } AutoreleasePool 为何可以嵌套使用 多层嵌套就是多次插入哨兵对象，系统哨兵对象插入 分析中所使用的方法 Clang 汇编: Debug -> Debug workflow -> 源码 Clang 生成 .cpp xcrun -sdk iphonesimulator clang -arch x86_64 -rewrite-objc main.m __At C++ 文件 mm， Source Code Type Objective C++ Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/base/retain-cycle.html":{"url":"markdown/base/retain-cycle.html","title":"循环引用","keywords":"","body":"循环引用 分类 /// 自循环引用 { id __strong obj -> self } /// 相互循环引用 { A { id __strong obj -> B } B { id __strong obj -> A } } /// 多重循环引用 { A { id __strong obj -> B } B { id __strong obj -> C } C { id __strong obj -> A } } 破除循环引用 避免产生循环引用 在合适的时候手动断环 具体解决方案 __weak __block __unsafe_unretained /// __weak { A { id __weak obj -> B } B { id __strong obj -> A } } /// __block 破解 MRC 下，__block 修饰对象不会增加引用计数，避免了循环引用 ARC 下，__block 修饰对象会被强引用，无法避免循环引用，需手动解环 /// __unsafe_unretained 修饰对象不会增加其引用指针，避免了循环引用 如果被修饰对象在某一时机被释放，会产生悬垂指针 场景 代理 Block NSTimer RunLoop 强持有 NSTimer NSTimer 强持有 objc_A(视图)，objc_A 强持有 NSTimer objc_A 被 VC 持有 当 NSTimer 是一个循环定时器时，NSTimer 会一直持有 objc_A，造成循环引用 需要添加一个中间对象，中间对象弱持有 objc_A 然后每次定时器循环时对 objc_A 是否为 nil，如果 objc_A == nil，timer invaild， 并且置空 大环引用 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/base/response-chain.html":{"url":"markdown/base/response-chain.html","title":"响应者链","keywords":"","body":"响应者链 Cocoa Event Handling Guide Events (iOS) Touches, Presses, and Gestures iOS事件处理，看我就够了~ 与手机 APP 进行交互中，我们会通过手势、传感、远程控制来和 APP 进行交互；决定由谁来响应这个事件的机制被称为响应者链 输入「事件」，输出「响应者」，然后来决定谁来响应 继承 UIResponse 的对象被称为响应者，需要决定由谁来响应该事件，称为第一响应者 原理 页面之间呈现的是树状结构 首先，用户在进行 APP 交互时，肯定有一个 View 是最靠近用户的 比如说我们在最靠近 View3 触发了一个点击手势，那我们要怎么确认是 View3 是我们要找的 View 用户触发事件 UIEvent UIEvent 由一个或多个 UITouch 组成 UITouch 说明一个手指的变化情况，UITouch 绑定 UIResponse 通过 IO.Kit 发送事件到 Window Server Window Server 通过将事件发送给合适的 UIApplication 事件被包装为 Event Source 发送到 UIApplication Main Thread RunLoop Event Source 包含很多 UIEvent 通过 histTest:view 和 pointInView: 找到对应的视图 然后再通过 Response Chain 响应者链，找到对应的响应者；HitTestView -> Super View -> UIWindow -> UIApplication -> UIApplication.Delegate 执行 UIResponse 协议方法 /// touchesBegan:withEvent: 在开始阶段调用触摸对象。 /// touchesMoved:withEvent: 在移动阶段调用触摸对象。 /// touchesEnded:withEvent: 在 Ended 阶段调用触摸对象。 /// touchesCancelled:withEvent: 当某些外部事件（例如，来电）导致操作系统取消多点触控序列中的触摸对象时调用 通过 Target-Action 找到对象 Selector 实现 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/base/category.html":{"url":"markdown/base/category.html","title":"Category","keywords":"","body":"Category \b分类中重写了原类方法导致原类中的方法被覆盖了，category 的底层实现是在加载的时候，把 category 中的方法添加到原类的方法列表中，当调用方法时，会遍历方法列表找到对应的响应就返回，不再向下遍历，因为 category 优先级高于子类的优先级，使得原类的方法没有被调用 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/base/association.html":{"url":"markdown/base/association.html","title":"Association","keywords":"","body":"Association 关联对象如何进行内存管理，关联对象如何实现 weak 属性? 关联对象的 ObjectAssociation 中有两个属性 (uintprt_t _policy, id value)，_policy 包含 retain，assign copy，会对应的对象进行和普通对象一样的内存管理操作 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/base/notification.html":{"url":"markdown/base/notification.html","title":"Notification","keywords":"","body":"Notification Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/base/sand-box.html":{"url":"markdown/base/sand-box.html","title":"沙盒","keywords":"","body":"SandBox Apple.FileSystem 在 Apple 文件系统中（APFS），每个进程拥有对应的文件系统进行数据持久化，进程之间不相互共享，用户无法直接获得文件系统中的内容 >> 沙盒路径目录如下 Document - 用户存储用户生成的文件 Library - 这个目录下有两个子目录，存储不向用户公布的文件 Preferences - 包含应用程序的偏好设置文件，通常使用 NSUserDefault Caches - 保存应用程序再次启动过程中需要的信息 Tmp - 这个目录用于存放临时文件，关闭应用程序将会清除 二、相关代码 获取 Sandbox 路径 NSString *homeDir = NSHomeDirectory() 获取 Documents 目录 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *docuDir = [paths firstObject]; 获取 Library 目录 NSArray *paths = NSSearchPathForDiectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES); NSString *libDir = [paths lastObject]; 获取 Cache 目录 NSArray *paths = NSSearchPathForDiectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES); NSString *cachesDir = [paths firstObject]; 获取 tmp 目录 NSString * tmpDir = NSTemporaryDirectory(); -- 其他路径 模拟器的位置 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs 文档安装位置 /Applications/Xcode.app/Contents/Developer/Documentation/DocSets/ 插件保存路径 ~/Library/ApplicationSupport/Developer/Shared/Xcode/Plug-ins 自定义代码段的保存路径 ~/Library/Developer/Xcode/UserData/CodeSnippets 如果找不到 CodeSinppets 文件夹，可以自己新建一个 CodeSnippets 文件夹 证书路径 ~/Library/MobileDevice/Provisioning Profile Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 16:55:22 "},"markdown/network/network-introduction.html":{"url":"markdown/network/network-introduction.html","title":"网络编程","keywords":"","body":"网络编程 该章节目前主要讲 HTTP、MQTT、TCP、UDP、DNS、Socket 等 OSI (Open System Interconnect)，即开放式系统互联，一般都叫 OSI 参考模型。OSI 定义了网络互联的七层框架（物理层、数据链路层、网络层、传输层、会话层、表现层、应用层） TCP/IP 参考模型，四层协议（数据链路层、网络层、传输层、应用层） 应用层，最靠近用户的一层，为计算机用户提供应用接口，直接为用户提供网络服务。常见网络协议由 HTTP / HTTPS / FTP / TELNET 等 传输层，为上层协议提供端到端的数据传输服务，我们通常说 TCP UDP 就是在这一层 网络层，通过 IP 寻址来建立两个节点之间的连接，通过合适的路由和交换节点，正确无误地按照地址传送给目的运输层 数据链路层，通过一些规程或协议来控制这些数据的传输，以保证被传输数据的正确性，实现这些规程或协议的硬件和软件加到物理线路 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/network/http.html":{"url":"markdown/network/http.html","title":"HTTP","keywords":"","body":"HTTP （建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系 HTTP（Hypertext Transfer Protocol）超文本传输协议，用于规定客户端与服务端之间的应用层传输协议。超文本不单单只是文本，还可以传输图片、音频、视频等 设计目的 提供一种发布和接收 HTML 页面接收的方法 特点 无状态，Cookie / Session 同一个客户端每次请求之间是没有对应关系的 无连接，HTTP 的持久连接；非持久链接，每次发起请求，响应后都关闭；持久链接，在开启后延迟一段时间后才断开 应用层: OSI 参考模型的最高层，是用户与网络的接口，该层通过应用程序来完成网络用户的应用请求 URL 统一资源定位符 URL (Uniform Resource Locator)，地址例如 http://www.xxx.com/img/logo.png，包含协议、IP 地址/域名 常见协议 常见协议 格式 作用 HTTP http:// 超文本传输协议，访问远程网络资源 file file:// 访问本地计算机上的资源 mailto mailto: 访问电子邮件地址 FTP ftp:// 访问共享主机的文件资源 URI & URL 统一资源标识符（URI）可以是名称或者定位符、也可以两者皆有，URI 只能提供标识，并不能提供访问方式；当字符串中含有 http:// 那它是一个 URL，URL 能够具体告知资源如何访问 /// 所有的 URL 都是 URI，但并非所有的 URI 都是 URL URI (identifier): ISBN 0-486-27557-4 { URN (name): urn:isbn:0-486-27557-4 URL (locator): https://google.com } URL 中带中文问题 如果地址是英文/数字，原样发送，如果是空格，转换为 +，如果是中文/其他字符，则直接把字符串用 BASE64 编码，得出 %XX，XX 为该符号以 16 进制表示的 ASCII NSString *urlEncode = [url stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet characterSetWithCharactersInString:url]]; 端口 HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443 请求报文组成 { /// 请求方法 + 请求 URL + HTTP 协议及版本 = 请求行 POST /chapter17/user.html HTTP/1.1 /// 请求头 Accept: image/jpeg, application/x-ms-application, ..., */* Referer: http://localhost: 888/chapter17/user/register.html Accept-Language: zh-CN User-Agent: Mozilla/4.0 Host: localhost:8088 Content-Length: 112 Connection: Keep-Alive Cache-Control: no-cache Cookie: JSESSIONID=123123SDJJSKD98J34J /// 请求主体 name=tom&password=12&realName=tomson } 请求方法 GET / POST / DELETE / HEAD / OPTIONS / PUT / TRACE / CONNECT GET GET 通常用来获取资源，安全、幂等、可缓存。这里的安全性指的是不引起 Server 端的任何变化，幂等指同一个请求方法执行多次和执行一次的效果完全相同，常见的场景是通过网页上的链接在浏览器上面浏览网页，请求参数和对应的值附加在 URL 后面，利用一个问号？代表 URL 的结尾与请求参数的开始，各个参数之间用 & 符号隔开，例如: /index.jsp?id=100&op=bind 实际上，HTTP 协议并没有对 URL 进行长度限制，实际上的限制是特定浏览器及服务器端对它的限制，不适合传输大量数据 GET 请求的请求信息都在请求参数里面，易获取 GET 请求在发送过程中会产生一个 TCP 数据包，客户端会把 HTTP Header 和 data 一并发出去，服务器响应 200 返回数据 POST POST 通常用来处理资源，非安全、非幂等、不可缓存，使用 POST 方法可以允许客户端给服务器提供较多的信息，POST 方法将请求封装在 HTTP 请求数据中，以 key:value 的方式出现，可以传输大量数据，POST 对传送的数据大小没有限制，也不会显示在 URL 中，POST 请求也能完成 GET 的功能 POST 请求将参数放在请求体 Body 中，对用户来说不可见 POST 请求在发送过程中会产生两个 TCP 数据包，客户端先发送 Header，服务器响应 100，然后再发送 data，服务器响应 200 HEAD HEAD 类似 GET，只不过服务器接受到 HEAD 请求后只返回响应行，而不会响应内容 当我们只需要查看某个页面的状态的时候，使用 HEAD 是非常高效的，因为再传输过程中省去了页面内容 请求 URL 请求对应的 URL 地址，和报文头的 Host 属性，组合起来是一个完整的 URL 协议版本 协议名称及版本号 请求头 有若干个属性，形式为 key: value，用于服务端获取客户端的一些附加信息 NSURLRequest / NSMutableURLRequest 的 setvalue: forHTTPHeaderField: 常见报文头属性 属性 解释 Accept 告诉服务端，客户端接收什么类型的响应 Referer 表示该请求是从哪个 URL 进来的 Cache-Control 对缓存进行控制，例如缓存的过期时间或者设置不设缓存 Accept-Encoding 告诉服务端自己能接受什么编码格式，包括字符编码，压缩形式 Accept-Language 设置接受的语言 Host 指定要请求的资源所在的主机和端口 User-Agent 告诉服务器，客户端使用的操作系统、浏览器版本和名称 请求体 将一个页面表单中的组件值通过 param1=value1&param2=value2 键值对的形式编码成一个格式化串，它承载多个请求参数的数据，不但报文头可以传输请求参数，URL 也可以通过 /chapter15/user.html?param1=value1&param2=value2 的方式传递数值 NSURLRequest / NSMutableURLRequest 的 HTTPBody 响应报文 与请求报文一样，由三个部分组成: 响应行、响应头、响应体 { /// 报文协议及版本 状态码及状态描述 HTTP/1.1 200 OK /// 响应头 Server: Apache-Coyote/1.1 Content-Type: application/json Transfer-Encoding: chunked Date: Mon, 12 Sep 2011 12:41:24 GMT /// 响应体 { \"password\": \"1234\", \"userName\": Justin } } 状态码 状态码 含义 100~199 消息 -- 成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程 200~299 成功 -- 成功接收请求，并已经完成整个处理过程 300~399 重定向 -- 为完成请求，客户端需进一步细化请求。例如，请求的资源已经移动一个新的地址 400~499 请求错误 -- 客户端的请求有错误 500~599 服务器错误 -- 服务器端出现问题 常见状态码 状态码 含义 200 OK 表示成功 303 重定向，重定向到其他页面 304 资源并未修改，可以直接使用本地的缓存 404 找不到页面（页面被删除或其他） 500 服务器错误 响应报文属性 属性 Key 含义 Cache-Control 响应输出到客户端后，服务器通过该属性告诉客户端该怎么控制响应内容的缓存 ETag 表示你请求资源的版本，如果该资源发生变化，那么这个属性也会跟着变化 Location 在重定向中或者创建资源时使用 Set-Cookie 服务端可以设置客户端的 Cookie HTTP 的历史演化 HTTP / 1.1 之前 不支持持久连接，一旦服务器对客户端发出响应就立即断开 TCP 连接 无请求头和响应头 客户端的前后请求是同步的，下一个请求必须等上一个请求从服务器拿到响应后才能发出，有点类似于多线程的同步机制 HTTP / 1.1 增加请求头和响应头 支持持久连接，客户端通过请求头指定 Connection 为 keep-alive 告知服务器不要在完成响应后立即释放链接。HTTP 基于 TCP 连接，在 HTTP 1.1 中一次 TCP 连接可以处理多次 HTTP 请求 客户端不同请求之间是异步的，下一个请求不必等到上一个请求回来后再发出，而是可以持久发出请求，有点类似于多线程的异步处理 HTTP 2.0 只用于 HTTPS 地址 HTTP 3.0 持久连接 请求头部字段 /// 设置持久连接 Connection: keep-alive /// 持久连接持续时长 time: 20 /// 这个连接对多可以发生多少次 HTTP 请求响应对 max: 10 如何判断一个请求是否结束？ /// 1. 客户端接收的最大长度 Content-length: 1024 /// 2. chunked, 最后会有一个空的 chunked 如果连接被频繁地启动然后断开，就会花费很多资源在 TCP 三次握手和四次挥手上，效率低下 建立过程 1. TCP 三次握手: SYN, SYN/ACK, ACK 2. HTTP 请求报文、http 响应报文 3. TCP 四次挥手: FIN, ACK, FIN/ACK, ACK 无状态 - Cookie HTTP 是一个无状态协议，指的是每次请求相对独立，没有记忆功能；例如用户登录了一个网页，然后关闭浏览器，当用户再次打开该网页的时候，还是需要重新登录。当然现在在浏览器中，我们再次打开浏览器，下次登录不再需要重新输入用户名和密码，是因为 Cookie 发生了作用，能够让浏览器有记忆功能。 Cookie 一般存在请求头中，示例: Cookie: JSSESSIONID=xxxxxxxxx。一般过程如下 客户端发起请求 服务端在响应报文中，返回 Set-Cookie 客户端在后面发起请求时都会携带 Cookie，放在请求头里面 抓包原理 中间人攻击 Client -> Server Client -> 中间人 -> Server HTTPS HTTPS 是以安全为目的的 HTTP 通道，即 HTTP 下加入 SSL 层进行加密 SSL (Secure Sockets Layer) 安全套接字层 TLS (Transfer Layer Security) 传输层安全协议，标准化 SSL 后的命名，可视为与 SSL 同一个东西的不同阶段 HTTP 协议以明文的方式发送内容，不提供任何方式的数据加密，如果攻击者截取了 Web 浏览器和网站服务器之间的传输报文，就可以直接读取其中的信息，因此 HTTP 协议不适合传输一些敏感信息，例如信用卡号、密码等等。 SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；使用的端口是 443 建立过程 Client 告知 Server 端 TLS 版本号、支持的加密算法、random number C Server 确认支持的加密算法，Server 保存着私钥，random number S, server 证书（携带公钥） Client 通过证书信任链以及数字签名验证证书 Client 通过服务器公钥来生成一个前主密钥(Pre-Master Secret, PMS), 并通过该前预主密钥和 random number c 和 random number S 组装成会话密钥 Client 通过 Server 的公钥对预主密钥进行加密发送给 Server Server 通过私钥解密得到预主密钥 Server 通过 random number c 和 random number s 和与预主密钥组装会话密钥 会话密钥 = random S + random C + 预主秘钥，建立过程中使用非对称加密，非对称加密相对耗时，所以在正式通信过程中使用对称加密 WWDC 16 在 WWDC 16 苹果宣布之后所有应用程序必须启用 App Transport Security 安全功能，App Transport Security (ATS) 是苹果在 iOS 9 中引入的一项隐私保护功能，屏蔽铭文 HTTP 资源加载，连接必须进入更安全的 HTTPS CRLF POST body 使用 form-urlencoded 和 multipart/form-data application/x-www-form-urlencoded: 窗体数据被编码为名称/键值对，这是标准且默认的编码格式。当 action 为 get 的时候，客户端把 form 数据转换成一个字符串 append 到 url 后面，用 ? 分割。当 action 为 POST 的时候，浏览器把 form 数据封装到 http body 中，然后发送给 server multipart/form-data: multipart 表示的意思是单个消息头包含多个消息体的解决方案，multipart 媒体类型对发送非文本的各媒体类型是有用的。一般多用于文件上传。 multipart/form-data 只是 multipart 的一种。目前常用的有以下这些类型 注: 任何一种执行时无法识别的 multipart 子类型都被视为子类型 \"mixed\" Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/network/tcp.html":{"url":"markdown/network/tcp.html","title":"TCP","keywords":"","body":"TCP TCP (Transmission Control Protocol)，传输层控制协议 TCP 是面向连接的协议，在发送数据前先需要建立连接，然后再发送数据；TCP 会按照特定顺序重新排列数据包，相对传输速度较慢，在发送任何用户数据之前，TCP 需要三次握手建立连接 头部结构 20 bytes Name Size Source Port（源端口号） 2 byte Destination Port（目的端口号） 2 byte Sequence Number (序列号) 4 byte Acknowledge Number (if ACK set) 4 byte Data offset 4 bit Reserved 3 bit NS、CWR 、ECE 、URG、ACK、PSH、RST、SYN、FIN 9 bit Window Size 2 byte CheckSum 2 byte Urgent Pointer (if URG set) 2 byte Options (if data offset > 5, Padded at the end with \"0\" bytes if necessary) rest 三次握手 需要确认双方都能够通信；你能收到消息吗？我可以，你可以接收到我的消息吗？我也可以 Server Receive Check Passsed Client 发送 SYN 信号，Sequence Number = x；然后处于 SYN_SENT 状态，Server 收到后进入 SYN_RCVD Client Receive And Send Check Passed Server 发送 ACK + SYN 信号，Acknowledge Number = x+1，Sequence Number = y; Client 收到后进入 ESTABLISHED 状态 Server Receive Check Passsed Client 发送 ACK 信号，Acknowledge Number = y+1，Server 收到后进入 ESTABLISHED 可不可以只设置两次握手？不可以，首先丢失最后一步，会造成如果 Client 接收能力缺失，但是却建立连接的情况 四次挥手 需要确认双方都已经断开连接；我准备断开连接了。好的，我也准备断开连接。好的 Client 发送 FIN 信号，然后处于 FIN_WAIT_1 状态，Server 收到后处于 CLOSE_WAIT 状态，确认是否关闭，此时 Server 还能接收数据 Server 发送 ACK 信号，确认已经可以关闭，Client 收到后处于 FIN_WAIT_2 状态，Server CLOSE_WAIT Server 发送 FIN 信号，Server 进入 LAST_ACK 状态，Client 收到后进入 TIME_WAIT 状态 Client 发送 ACK 信号，Server 收到后处于 CLOSE 状态 为什么关闭连接时会比建立连接多出来一步，因为 Server 端被动关闭时，此时还有可能有数据没有发送成功，需要等待至可关闭状态，然后发送 FIN 信号 2MSL MSL (Maximum Segment Lifetime) 报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间 在四次挥手中，2MSL 能够确保足够长的等待时间，确保在处理下次指令时，不会受到来自上次迷路报文的干扰 TIME_WAIT，Client 收到 Server 的 FIN 信号后，然后发送 ACK 信号，进入 TIME_WAIT 状态，TIME_WAIT 需要等待 2MSL 时间。其中一个 MSL 是 Server 端收到 ACK 信号的超时时间，另外一个 MSL 是 Server 没有收到 ACK 信号后重新发送 FIN 信号的超时时间 CLOSE_WAIT，与 TIME_WAIT 同理，Server 端收到 Client 的 FIN 信号后，进入 CLOSE_WAIT 状态，CLOSE_WAIT 需要等待 2MSL 时间。其中一个 MSL 是 Client 端收到 ACK 信号的超时时间，另外一个 MSL 是 Client 没有收到 ACK 信号后重新发送 FIN 信号的超时时间 差错校验 拥塞控制 慢启动、拥塞避免 TCP 发送端会维护一个拥塞窗口 cwnd，拥塞窗口初始为 1 个报文段，每次经过一次 RTT (数据完全发送到确认时间)，窗口大小会翻倍，指数型增长。当 cwnd 增长到阈值 ssthresh 之后，每经过一个 RTT 就把拥塞窗口加一，线性增长。当检测到拥塞后，cwnd 重置为 1 个报文段，且 ssthresh 变成拥塞时 cwnd 的一半，重新走慢启动和拥塞避免 快重传、快恢复 失败重传 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/network/udp.html":{"url":"markdown/network/udp.html","title":"UDP","keywords":"","body":"UDP 面向无连接传输协议，发送数据前不需要建立连接，没有可靠性 支持一对一、一对多、多对一、多对多；也就是支持单播、多播、广播的功能 面向报文传输，发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，因此应用程序必须选择合适大小的报文 UDP 首部开销 8 个字节 Source port(2byte) | Destination port(2byte) | Length 整个数据报文的长度(2byte) | checksum 整个数据报的检验和(2byte) | UDP 不需要维持复杂的连接状态表 对实时性要求很高的场景使用 UDP，比如游戏，媒体通信，实时直播，即使出现传输错误也可以容忍 通信不需要建立连接，收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据，UDP 因为没有拥塞控制，会以恒定的速度发送数据。所以在网络不好的情况下可能会导致丢包 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/network/socket.html":{"url":"markdown/network/socket.html","title":"Socket","keywords":"","body":"Socket Socket 本身并不是协议，而是调用接口 (API)，通过 Socket 我们才能使用 TCP/IP 协议 Socket 连接，长链接，客户端跟服务端直接使用 Socket 进行连接，没有规定连接后断开，因此客户端和服务端保持连接通道，双方可以主动发送数据 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/network/dns.html":{"url":"markdown/network/dns.html","title":"DNS","keywords":"","body":"DNS IP & 域名 IP 地址: 191.168.1.1、域名: www.xxx.com 一般来讲一个域名对应一个 IP 地址，由于 IP 地址不好记录，所以给 IP 地址起了一个别名，就是域名。互联网访问的方式，输入域名，域名解析服务器（DNS）解析成 IP 地址，访问 IP 地址 DNS 是应用层协议，事实上他是为其他应用层协议工作的，包括不限 HTTP 和 SMTP 以及 FTP，用于将用户提供的主机名解析为 ip 地址 用户主机的 DNS 客户端接收到后，向网络中发送一个 DNS 查询报文，所有 DNS 请求和回答报文使用的 UDP 数据报经过端口 53 发送，经过若干 ms 到若干 s 的延时后，用户主机上的 DNS 客户端接收到一个提供所希望映射的 DNS 回答报文。这个查询结果则被传递到调用 DNS 的应用程序 DNS 主要基于 UDP 运输层协议，尽最大能力交付的不可靠数据连接，一次 UDP 名字服务器交换可以短到两个包: 一个查询包、一个响应包。一个 TCP 交换则至少包含 9 个包: 三次握手初始化 TCP 会话、一个查询包、一个响应包以及四次分手的包交换；考虑到效率原因，TCP 连接的开销较大，故采用 UDP 作为 DNS 的传输层协议 DNS 使用的是分布式集群的工作方式，而不是集中式的设计方式。集中式设计会有单点故障、通信容量、远距离的是时间延迟、维护开销大 DNS 服务器一般分为三种: 根 DNS 服务器、顶级 DNS 服务器、权威 DNS 服务器 工作原理 DNS 客户端需要查询程序中使用的名称时，它会查询本地 DNS 服务器来解析该名称。客户端发送的每条查询消息都包含 3 条信息，以指定服务器应回答的问题 指定的 DNS 域名，表示为完全合格的域名(FQDN) 指定查询类型，它可根据类型指定资源记录，或作为查询操作的专门类型 DNS 域名的指定类别 |- 域名解析 |- 本地 host 文件 |- 本地 DNS 解析器缓存 |- 本地 DNS 服务器（TCP/IP 参数中设置的首选） |- 本地 DNS 服务器缓存/区域文件 |- 本地 DNS 服务器（非转发模式），发送至 13 台根 DNS 服务器，然后依次寻找下级域名直到找到主机，最后把结果返回给本地 DNS 服务器，由此 DNS 服务器再返回给客户端 |- 本地 DNS 服务器（转发模式），发送至上级 DNS 服务器，如果找不到再转发到上上级，最后把结果返回给本地 DNS 服务器，由此 DNS 服务器再返回给客户端 DNS 劫持 设置可靠的本地 DNS 服务器 由于 DNS 采用 UDP 数据报，容易被劫持，所以可以直接使用 HTTP 协议透传到 HTTPDNS 服务器上 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/network/mqtt.html":{"url":"markdown/network/mqtt.html","title":"MQTT","keywords":"","body":"MQTT MQTT MQTT-Essentials MQTT(Message Queuing Telemetry Transport, 消息队列遥测传输协议)，一种基于发布/订阅(public/subscribe) 模式的 \"轻量级\" 协议，基于 TCP/IP 协议 { 低开销、低贷款占用，小型传输，固定长度的头部是 2 字节 有三种消息发布的服务质量，至多一次、至少一次、只有一次 常见领域: 卫星链路通信传感器、偶尔拨号的意料器械、智能家具、以及一些小型化设备中已广泛使用 } 分为三个身份: 发布者(publish)、消息代理服务器(Broker)、订阅者(Subscribe)；消息发布者也可以是订阅者 MQTT 传输的消息分为: 主题(Topic) 和 负载(payload) 两个部分 每个客户端与服务端建立连接后就是一个会话，一个会话存在于一个网络中，也可能在客户端和服务端之间跨越多个连接的网络连接，即一个会话可以包含多个订阅 MQTT 数据包结构: 固定头(Fixed header)、可变头(Variable header)、消息体(payload) 三部分构成 MQTT 固定头是两个字节 Byte 1 控制报文的类型 4bit | 控制报文类型的标志位 4bit Byte 2 剩余长度 8bit 控制报文类型 Reserved 0 系统保留 CONNECT 1 客户端请求连接服务端 CONNACK 2 连接报文确认 PUBLISH 3 发布消息 PUBACK 4 消息发布收到确认（QoS 1） PUBREC 5 发布收到（QoS2） PUBREL 6 发布释放（QoS2） PUBCOMP 7 消息发布完成（QoS2） SUBSCRIBE 8 客户端订阅请求 SUBACK 9 订阅请求报文确认 UNSUBSCRIBE 10 客户端取消订阅请求 UNSUBACK 11 取消订阅报文确认 PINGREQ 12 心跳请求 PINGRESP 13 心跳响应 DISCONNECT 14 客户端断开连接 Reserved 15 系统保留 MQTT 对于异常断开有遗言 LWT(Last Will and Testament)，最后一条遗嘱消息是一条普通的 MQTT 消息，带有一个主题、保留的消息标志、Qos 和有效负载。客户端在发送 CONNECT 消息到 Broker 时指定一条 LWT 消息，Broker 存储消息，当客户端因意外断开，Broker 将 last-will 消息发送到 last-will 消息主题的所有订阅客户端，如果客户端正确的 DISCONNECT 消息正常断开，则代理将丢弃存储的 LWT 消息，Broker 在以下情况下会发送 LWT 消息: Broker 检测到 I/O 错误或者网络异常 客户端无法在定义的 Keep Alive 内进行通信 客户端在断开网络之前发送 DISCONNECT 消息 由于协议错误，Broker 关闭网络连接 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/network/rtsp.html":{"url":"markdown/network/rtsp.html","title":"RTSP","keywords":"","body":"Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/network/arp.html":{"url":"markdown/network/arp.html","title":"ARP","keywords":"","body":"Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 01:51:35 "},"markdown/network/jiami.html":{"url":"markdown/network/jiami.html","title":"加密算法","keywords":"","body":"加密篇 非对称加密 用公钥和私钥来加解密 公钥(Public Key) 与私钥(Private Key)是通过一种算法得到的一个密钥对（即一个公钥和一个私钥），公钥是密钥对中公开的部分，私钥则是非公开的部分，私钥通常是保存在本地 用公钥进行加密，就要用私钥进行解密；反之，用私钥加密，就要用公钥进行解密（数字签名） 由于私钥是保存在本地的，所以非对称加密相对与对称加密是安全的，但非对称加密比对称加密耗时（100倍以上），所以通常要结合对称加密来使用 常见的非对称加密算法有: RSA、ECC（移动设备用）、Diffie-Hellman、EI Gamal、DSA（数字签名用） 对称加密 使用同一套密钥来进行加密解密 对称加密通常有 DES、IDEA、3DES 加密算法 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 01:51:35 "},"markdown/kuozhan/kuo-zhan.html":{"url":"markdown/kuozhan/kuo-zhan.html","title":"扩展题","keywords":"","body":"扩展篇 相册组件怎么实现? 需要注意什么问题 图片缩放 图片缓存的话放到哪里 原生相册是怎么做到那么流畅的 推送 deviceToken 是否可以注销 Bugly 原理 卡顿检测 - RunLoop FMDB 会导致崩溃的原因 跨平台方案实现？Flutter 的原理？是怎么渲染到屏幕上的 遇到的难题 检测内存泄露的方法 { 静态分析 { Product -> Analyze } 动态分析 { Instrument -> Leak 动态分析内存泄露(优点: 不需要写新的代码；缺点: 需要一个一个页面去点击) Instrument -> Allocation 工具了解内存的分配情况 Debug Memory Graph 了解各个对象的持有情况 MLeaksFinder { 通过 hook viewController 的 viewWillAppear 和 viewDidDisappear 等方法中，认为在 viewDidDisappear 等方法后，需要销毁；能检测出内存泄露和循环引用，并且弹框提醒 } } } 定位 Bug Crash 防护怎么做 参照 AvoidCrash，使用 Method_Swizzling 替换原本方法实现，在会引起崩溃的地方添加默认实现，并收集错误堆栈，上报 Bugly 断点续传如何实现 断点续传分为两部: 断点、续传 首先需要为每条下载数据，保存当前下载进度 在每次下载开始之前需要先读取数据库，查询是否有未完成的记录，有就继续下载，没有就创建新的任务 在每次文件写入的过程中往数据库中写入下载进度 下载完成后，删除数据库中的下载记录 NSURLSessionDownloadTask API 说明 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/kuozhan/app-commucation.html":{"url":"markdown/kuozhan/app-commucation.html","title":"进程间通信","keywords":"","body":"进程间的通信方式 每个 APP 都由一个进程进行维护，iOS 是相对封闭的系统，每个 APP 都有对各自的沙盒（Sandbox），每个 APP 都只能读到 iPhone 上 iOS 系统为该应用程序创建的文件夹 AppData 下的内容，不能随意跨域自己的沙盒去访问别的沙盒中的内容 URL Scheme APP_A 通过 openURL 的方式跳转到 APP_B，并且在 URL 中带上想要的参数，需要分别在 APP_A 和 APP_B 配置 URLScheme KeyChain 安全的存储容器、本质上是一个 sqllite 数据库，所有的数据均经过加密存储，可以用来为不同的 app 保存敏感信息，即使 APP 删除后，KeyChain 依然存在 { KeyChainItemWrapper: identifier、accessGroup { kSecAttrAccount: value1, kSecValueData: value2 } } UIPasteboard 系统粘贴板 UIDocumentInteractionController 用来实现同设备上 app 之间的共享文档，以及文档浏览、打印、发邮件、复制等功能 local socket 通过本地端口，APP_A 开启某个端口进行 TCP bind 和 listen，APP_B 对该端口进行 TCP Connect，缺点需要另外一个应用程序保活 AirDrop 支持不同设备的 APP 之间的文档和数据分享 UIActivityViewController 发送数据、分享数据和操作数据 APP Groups 利用 idenfitier 同个开发团队开发的 App 之间，包括 APP 和 Extension 之间共享一份读写空间进行数据共享 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 01:51:35 "},"markdown/framework/framework-introduction.html":{"url":"markdown/framework/framework-introduction.html","title":"架构","keywords":"","body":"架构篇 模块化 分层 解耦 降低代码重合度 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 01:51:35 "},"markdown/framework/image-cache.html":{"url":"markdown/framework/image-cache.html","title":"图片缓存","keywords":"","body":"图片缓存 { Manager 调度各个模块 // 多级缓存提高效率 Memory 内存，图片缓存 Disk 磁盘处理 Network 网络 Code Manager { 图片解码 图片压缩/解压缩 } } 读写 以图片 URL 的单向 Hash 值作为 Key 开始 -> 内存是否命中 -> 磁盘是否命中 -> 网络下载 内存设计 存储\b Size 淘汰策略 先进先出 LRU（30 分钟内是否使用过），定时检查、提高检查触发频率（每次进行读写、前后台切换）注意开销问题 磁盘设计 读取效率低、内存大 存储方式 大小限制（如 100MB） 淘汰策略（某一图片存储时间距今已超过 7 天） 网络设计 网络请求最大并发量 请求超时策略 请求优先级 图片解码 应用策略模式对不同图片格式进行解码 在哪个阶段做图片解码处理？磁盘读取后，网络请求返回后 线程处理 Manager - Memory Cache - Disk Cache - Network Download memory result Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 01:51:35 "},"markdown/leetcode/leetcode.html":{"url":"markdown/leetcode/leetcode.html","title":"算法题","keywords":"","body":"算法篇 哈希查找 哈希冲突 LRU 算法 Least recently used 最近最少使用 移除数组中的元素 while(item = [set anyObject]) { [set remove:item] } Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:17:27 "},"markdown/leetcode/leetcode-string.html":{"url":"markdown/leetcode/leetcode-string.html","title":"字符串处理","keywords":"","body":"字符串算法 to-lower-case length-of-last-word jewels-and-stones first-unique-character-in-a-string 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 s = \"leetcode\" 返回 0 s = \"loveleetcode\" 返回 2 class Solution { func firstUniqChar(_ s: String) -> Int { /// 字符出现次数 hash 表 var table: [Character: Int] = [:] /// 遍历 for char in s { /// 是否添加过 if table.keys.contains(where: { $0 == char }) { /// set value 次数 + 1 for char table[char] = table[char]! + 1 }else { /// set value(次数 = 1) for char table[char] = 1 } } print(table) /// 再次遍历 for (index, char) in s.enumerated() { /// 如果 get 次数 for char，次数 == 1，获取上一个索引，如果没有上一个则返回 -1 if table[char]! == 1 { return index } } /// 如果都没有返回 -1 return -1 } } longest-common-prefix class Solution { func longestCommonPrefix(_ strs: [String]) -> String { // 保存最长公共子串 var subStr = \"\" if strs.count == 0 { return subStr } if strs.count == 1 { return strs.first! } // 不存在 else { // 临时保存公共子串 var tmpSubStr = \"\" // 开始遍历第一个元素 for (index, char) in strs.first!.enumerated() { // 前缀过滤 var filterStrs = strs.filter({ $0.hasPrefix(tmpSubStr + String(char)) }) // 是的话更新 tmpSubStr， if filterStrs.count == strs.count { tmpSubStr.append(char) } // 前缀判断 if tmpSubStr == \"\" { return \"\" } // 否则 tmpSubStr 和 subStr 进行比较，判断 subStr 是否比这个短，如果 index 是最后一个也走这个流程 if index == strs.first!.count - 1 || filterStrs.count != strs.count { // 是的话更新 subStr // 否则不处理 if tmpSubStr.count > subStr.count { subStr = tmpSubStr } return subStr } } } return subStr } } Solution.init().longestCommonPrefix([\"flower\", \"flow\", \"flight\"]) /// 题目: 最长公共子串 /// 输入: strs = [\"flower\", \"flow\", \"flight\"] /// 输出: \"fl\" /// 条件 /// 1 reverse-string /* 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题 输入：s = [\"h\",\"e\",\"l\",\"l\",\"o\"] 输出：[\"o\",\"l\",\"l\",\"e\",\"h\"] */ class Solution { func reverseString(_ s: inout [Character]) { var begin: Int = 0 var end: Int = s.count == 0 ? 0 : s.count-1 // 不需要修改 if end == 0 { return } // 直到 begin == end 或者 begin > end 则不用交换 while begin reverse-words-in-a-string class Solution { func reverseWords(_ s: String) -> String { /// 利用空格分割字符串，得出字符串数组 var words = s.split(separator: \" \") /// 新建头尾指针 var begin: Int = 0 var end: Int = words.count == 0 ? 0 : words.count - 1 /// 不需要翻转 if end == 0 { return s } /// 元素翻转 while begin vaild-palindrome Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 16:18:45 "},"markdown/vendor/vendor-introduction.html":{"url":"markdown/vendor/vendor-introduction.html","title":"第三方库","keywords":"","body":"第三方库篇 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/vendor/SDWebImage.html":{"url":"markdown/vendor/SDWebImage.html","title":"SDWebImage","keywords":"","body":"SDWebImage |- UIKit |- UIImageView + WebCache |- SDWebImageManager |- SDImageCache |- SDWebImageDownloader 加载图片过程大致流程 |- setImageWithURL:placeholderImage:options: 会先显示 placeholderImage - SDWebImageManager |- downloadURL:delegate:options:userInfo:(SDWebImageManager) -> queryDiskCacheForKey:delegate:userInfo(SDImageCache) 缓存查找 |- 缓存找到 imageCache:didFindImage(SDImageCacheDelegate) -> SDWebImageManager |- SDWebImageManager 回调 webImageManager:didFinishWithImage: 到 UIImageView+WebCache 等前端展示图片 |- 内存未找到，生成 NSInvocationOperation 添加到队列中开始从硬盘查找图片是否已经缓存 |- 根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 中进行的操作，所以回主线程进行结果回调 notifyDelegate: |- 如果从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:，进而回调展示图片 |- 如果从硬盘缓存都读取不到图片，则回调 imageCache:didNotFindImageForKey:userInfo: |- 共享或重新生成一个下载器 SDWebImageDownloader 开始下载 |- 图片下载由 NSURLConnection 来做，实现相关 Delegate 来判断图片下载中、下载完成和下载失败 |- connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果 |- connectionDidFinishLoading: 数据瞎子啊完成后交给 SDWebImageDecoder 做图片解码处理 |- 图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI，如果有需要对下载的图片进行二次处理，也可以在此处进行处理 |- 在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成 imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader |- imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成 |- 通知所有 downloadDelegates 下载完成，回调给需要的地方展示图片 |- 将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程 |- SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用程序结束的时候清理过期图片 |- SDWebImage 也提供 UIButton+WebCache 和 MKAnnotation+WebCache，方便使用 |- SDWebImagePrefetcher 可以预先下载图片，方便后续使用 内部做 Decoder 的原因 由于 UIImage 的 imageWithData 函数是每次画图的时候才将 Data 解压成 ARGB 的图像，所以在每次画图的时候，会有一个解压缩操作，这样的效率很低，但是只要瞬时的内存需求。为了提高效率通过 SDWebImageDecoder 将包装在 Data 下的资源解压，然后画在另外一张图片上，这样这张新的图片就不需要重复解压了 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/vendor/AFNetworking.html":{"url":"markdown/vendor/AFNetworking.html","title":"AFNetworking","keywords":"","body":"AFNetworking |- 通信核心类，网络相关 API 的一层封装 |- AFURLSessionManager // 继承并实现其他协议 |- AFHTTPSesssionManager // HTTP |- 序列化类 |- AFURLRequestSerialization // 将传入的参数构造成 NSURLRequest |- AFHTTPRequestSerializer |- AFJSONRequestSerializer |- AFPropertyListRequestSerializer |- AFURLResponseSerialization // 将系统的 NSURLResponse 处理成我们需要的 responseObject |- AFHTTPResponseSerializer |- AFJSONResponseSerializer |- AFXMLParserResponseSerializer |- AFXMLDocumentResponseSerializer |- AFPropertyListResponseSerializer |- AFImageResponseSerializer |- AFCompoundResponseSerializer |- 辅助类 |- AFSecurityPolicy // 用户处理网络连接安全策略 HTTPS |- AFNetworkReachabilityManager // 网络状态监控 |- UIKit // 通过 Category 提供一下 UIKit 的便利方法 AFURLSessionManager 创建和管理 NSURLSession / NSURLSessionTask 实现 NSURLSessionDelegate 等协议的代理方法 引入 AFSecurityPolicy 保证请求安全 引入 AFNetworkReachabilityManager 监控网络状态 大致流程 通过 AFURLRequestSerialization 生成 NSURLRequest 通过 NSURLSession 和 NSURLRequest 生成一个 NSURLSessionTask 开启一个网络请求 NSURLSessionTask.taskIdentifier 作为 Key, AFURLSessionManagerTaskDelegate 作为 Value 保存在一个字典中 代码架构 NSURLSession 有两个初始化方式，第一个是使用系统共享的 session，另一中是自己创建的 session。AFN 选择的是自己创建的 session，所以每个请求都会创建一个 session，复用一个 session 可以减少握手和挥手的过程，提高请求速度，Apple 允许 iOS 设备上一个域名可以有四个连接同时存在。可以在外面对 AFN 进行二次封装，将 AFHTTPSesssionManager 复用为单例对象 缓存 提供三种缓存配置 默认会话模式，默认添加内存缓存和磁盘缓存 瞬时会话模式，只添加内存缓存，不实现磁盘缓存 后台会话模式，内存和磁盘都不进行缓存 缓存策略 NSURLRequestUseProtocolCachePolicy：对特定的URL请求使用网络协议中实现的缓存逻辑，这是默认的策略 NSURLRequestReloadIgnoringLocalCacheData：数据需要从原始地址加载，不使用现有缓存。NSURLRequestReloadIgnoringLocalAndRemoteCacheData：不仅忽略本地缓存，同时也忽略代理服务器或其他中间介质目前已有的、协议允许的缓存 NSURLRequestReturnCacheDataElseLoad：无论缓存是否过期，先使用本地缓存数据。如果缓存中没有请求所对应的数据，那么从原始地址加载数据 NSURLRequestReturnCacheDataDontLoad：无论缓存是否过期，先使用本地缓存数据。如果缓存中没有请求所对应的数据，那么放弃从原始地址加载数据，请求视为失败（即：“离线”模式） NSURLRequestReloadRevalidatingCacheData：从原始地址确认缓存数据的合法性后，缓存数据就可以使用，否则从原始地址加载 内存缓存 AFSecurityPolicy // MODE // 不使用固定的证书验证服务器，直接从客户端系统中的受信任颁发机构 CA 列表中去验证 - AFSSLPinningModeNone // 会对服务器返回的证书 PublicKey 进行验证 - AFSSLPinningModePublicKey // 代表会对服务器返回的证书同本地证书全部校验 - AFSSLPinningModeCertificate 当通过 HTTPS 协议收到服务端的 challenge 时，比如需要验证证书，会执行代理方法 - (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler 在这个代理方法中，用来自定义如何应对服务器端不同类型的认证挑战 判断接收服务器挑战的方法是否是信任证书 - 如何开启常驻子线程，为什么需要常驻子线程 历史版本 1.0 基于 NSURLConnection 的封装 2.0 两套实现，分别基于 NSURLConnection 和 NSURLSession，是专享 NSURLSession 的过渡版本 3.0 基于 NSURLSession 的封装 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/vendor/ReactiveCocoa.html":{"url":"markdown/vendor/ReactiveCocoa.html","title":"ReactiveCocoa","keywords":"","body":"ReactiveCocoa 函数响应式框架 信号、订阅 ReactiveCocoa 的核心类 RACSignal 信号 RACStream RACDynamicSignal、RACReturnSignal、RACEmptySignal、RACErrorSignal RACStream 抽象 empty return bind concat zipWith 信号代表一连串的状态 1 -> 2 -> 3 -> 4 -> end 在状态改变时，对应的订阅者 RACSubscriber 就会收到通知执行相应的指令 订阅 RACSubscriber start RACSignal -> subscribeNext: -> RACSubscriber -> sendNext: (Block 调用) -> sendCompleted initialize RACSubscriber -> invoke didSubscribe with (Block 成员变量持有) Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/vendor/AsyncDisplayKit.html":{"url":"markdown/vendor/AsyncDisplayKit.html","title":"AsyncDisplayKit","keywords":"","body":"AsyncDisplayKit 提升 iOS 界面渲染性能的一个框架 主要处理问题 减轻主线程的压力，尽可能放在子线程 Layout { 文本宽高计算 视图布局计算 } 放在子线程计算 Rendering { 文本渲染 图片解码 图形绘制 } UIKit Objects { 对象创建 对象调整 对象销毁 } 基本原理 ASNode UIView CALayer 后台线程 主线程 针对 ASNode 的修改和提交，会对其进行封装并提交到一个全局容器当中 ASDK 也在 RunLoop 中注册一个 Observer 当 RunLoop 进入休眠前，ASDK 执行该 loop 内提交的所有任务 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/mac/mac-introduction.html":{"url":"markdown/mac/mac-introduction.html","title":"Mac","keywords":"","body":"Mac 介绍 Mac 一些常见问题 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/mac/the-best-mac-apps.html":{"url":"markdown/mac/the-best-mac-apps.html","title":"The Best Mac Apps","keywords":"","body":"The Best Mac Apps Application Description Copy+ 剪贴板历史记录 Proxifier Mac系统全局代理 Snap 设置应用程序的快捷键 Postman 老牌API接口调试工具 OmniDiskSweeper 磁盘空间清理软件 MediaInfo 专业音视频信息提取 Knuff 远程推送测试工具 Github CheatSheet 快速查看mac应用快捷键 Sketch 最好用的矢量绘图软件 Prepo App icon 制作工具 Go2Shell 在当前目录打开终端 draw.io 好用的流程图绘制应用 LICEcap gif 动态截屏软件 KeyCastr 实时显示键盘符号 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/mac/python-related.html":{"url":"markdown/mac/python-related.html","title":"Python","keywords":"","body":"Python 安装路径 Mac 系统自带的 Python 路径，在其目录下的 Current/bin 可查看 Python 有多少个版本 /System/Library/Frameworks/Python.framework/Version HomeBrew 安装的 Python 路径 /usr/local/Cellar/python 执行文件路径 查看当前 python 路径 - which python Mac Python 在 /usr/bin/ 目录下 HomeBrew Python 在 /usr/local/bin/ 目录下 /usr/bin & /usr/local/bin 系统命令默认在 /usr/bin，用户命令默认放在 /usr/local/bin 环境变量 在终端输入下面的指令可以编辑环境变量，最好是增加变量，不要修改原有的 sudo vi /etc/paths 使用 echo $PATH 可以直接打印环境变量，从左到右依次排序。如果系统命令和用户命令冲突，则会根据 /etc/paths 中的环境变量顺序从上到下依次查找；在里面我们可以看到 /usr/local/bin 是优先于 /usr/bin；也就是只要确保 /usr/local/bin 中的 python 软连接到 HomeBrew 安装的 python 即可，在终端执行命令如下: sudo ln -f /usr/local/bin/python3.7 /usr/local/bin/python 其他 Python 指令 卸载 Homebrew 下的 python brew uninstall python@3.7 使用 Homebrew 更新 python brew upgrade python Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/mac/ying-yong-sun-huai.html":{"url":"markdown/mac/ying-yong-sun-huai.html","title":"应用已损坏，请移除废纸篓","keywords":"","body":"应用已损坏，请移除废纸篓 解决方法 终端运行 sudo spctl --master-disable，选中 系统偏好设置 - 安全性与隐私 - 通用 - 允许从以下位置下载的 App: 任何来源 如果第二步完成后依旧失败，在终端运行 sudo xattr -rd com.apple.quarantine {app 路径} 下面以 Sketch.app 为例 sudo xattr -rd com.apple.quarantine /Applications/Sketch.app Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "},"markdown/mac/add-blank-space-to-photo.html":{"url":"markdown/mac/add-blank-space-to-photo.html","title":"为图片添加空白区域","keywords":"","body":"为图片添加空白区域 有时候需要将竖屏的图片调整为一个横屏的图片，并以空白填充。下面讲一下如何利用 Mac 自带的预览 App 进行图片调整 操作流程 用 预览 App 打开照片 Common + A 选中图片，然后 Common + X 将其剪切到复制板 点击右上角菜单中的工具 -> 调整大小，取消比例缩放，然后输入所需要的尺寸 Common + V 将复制板上的图片放在调整好后的画布上，最后 Common + S 保存图片 Copyright © www.gitbook.com 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-21 11:12:00 "}}